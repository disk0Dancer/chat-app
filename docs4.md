# Отчёт по практическому заданию №4
# Автор: Чураков Григорий

## Тема работы
Реализация чат-приложения с использованием очередей сообщений RabbitMQ

---

## Очереди

### Очереди сообщений (Message Queue)
Очереди сообщений обеспечивают асинхронный обмен данными между компонентами распределённых систем. RabbitMQ — это брокер сообщений, использующий протокол **AMQP**, который поддерживает надёжную доставку сообщений, маршрутизацию и управление очередями.

Основные элементы RabbitMQ:
- **Обменники (Exchanges):** маршрутизируют сообщения в очереди.
- **Очереди (Queues):** хранят сообщения до их обработки.
- **Подтверждения (Acknowledgments):** гарантируют успешную обработку сообщений.

### Преимущества RabbitMQ:
1. Асинхронная обработка запросов.
2. Гибкость маршрутизации сообщений.
3. Надёжная доставка благодаря подтверждениям.

---

## Практическая часть

### Используемые технологии
- **RabbitMQ:** брокер сообщений для асинхронной коммуникации.
- **React и TypeScript:** фронтенд приложения.
- **Python** для разработки серверной части.
- **Библиотека `@stomp/stompjs`:** для взаимодействия с RabbitMQ через WebSocket.

---

### Реализация приложения

#### 1. Фронтенд

Задачи:
- Обеспечить пользовательский интерфейс для отправки и получения сообщений.
- Подключиться к RabbitMQ через WebSocket.
- Отображать сообщения в реальном времени.
- Индетифицировать клиента по логину.

Логика обработки:
1. Подключение к RabbitMQ через STOMP:
   ```tsx
   const stompClient = new Client({
       brokerURL: 'ws://localhost:15674/ws',
       debug: (str) => console.log('STOMP Debug:', str),
   });

   stompClient.onConnect = () => {
       stompClient.subscribe('chat', (msg) => {
           const body = JSON.parse(msg.body);
           setMessages((prev) => [...prev, body]);
       });
   };

   stompClient.activate();
   ```

2.	Отправка сообщения:
  ```tsx
  const sendMessage = () => {
    if (client) {
        const chatMessage = { sender: userLogin, message };
        client.publish({
            destination: `chat`,
            body: JSON.stringify(chatMessage),
        });
        setMessage('');
    }
};
```
3.	Интерфейс:
  - Поля для ввода логина и сообщения.
  - Кнопка для отправки.
  - Область для отображения сообщений.

#### 2. Бекенд

Задачи:
- Создать очереди для обработки сообщений.
- Обеспечить маршрутизацию сообщений от клиентов к чату.
- Индетифицировать клиента по логину

##### Логика обработки:

- Сервер подписывается на очередь login.
  - При получении сообщения из очереди клиент создает для клиента очередь и запоминает логин к которому привязана очередь.
  - При получении сообщения о выходе клиента из чата, удаляет очередь и запись о клиенте.
    
- Сервер подписывается на очередь chat.
  - Рассылает сообщения всем подключённым клиентам.

```python
users = {}  # {"<login>": "<uuid>"}


def login_callback(body):
    try:
        print(f"Получена команда входа: {body}")
        action = body.get("action")
        login = body.get("login")
        queue = body.get("queue")

        if action == "login" and login and queue:
            create_queue(queue)
            users[login] = {"queue": queue}
            print(f"Пользователь {login} вошел в систему с очередью {queue}")
        elif action == "logout" and login:
            if login in users:
                del users[login]
                print(f"Пользователь {login} вышел из системы.")
    except Exception as e:
        print(f"Ошибка в login_callback: {e}")


def chat_callback(body):
    try:
        print(f"Получено сообщение чата: {body}")
        for user, data in users.items():
            send_message(data["queue"], body)
    except Exception as e:
        print(f"Ошибка в chat_callback: {e}")
```

#### Тестирование

1.	Сценарий 1: Один сервер, несколько клиентов.
 
	•	Сообщения успешно отправляются и доставляются.
	•	Клиенты видят обновления в реальном времени.

3.	Сценарий 2: Несколько серверов.

  •	Сообщения доставляются только в одну очередь.
	•	Для поддержки нескольких серверов требуется модификация архитектуры.

  
